(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{134:function(n,e,o){o(135),o(342),n.exports=o(339)},335:function(n,e,o){var r={"./0-docker-intro.md":336,"./1-docker-basics.md":337,"./2-docker-deploy.md":338};function i(n){var e=c(n);return o(e)}function c(n){if(!o.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}i.keys=function(){return Object.keys(r)},i.resolve=c,n.exports=i,i.id=335},336:function(n,e){n.exports='<h1 id="docker分享">docker分享</h1>\n<hr>\n<h1 id="主要内容">主要内容</h1>\n<ul>\n<li>docker简介</li>\n<li>核心概念</li>\n<li>demo(dockerize node server)</li>\n<li>线上docker部署</li>\n</ul>\n<hr>\n<h1 id="docker是什么">docker是什么</h1>\n<hr>\n\x3c!-- note\ndocker经常被描述为"集装箱"么，它的目的主要是为了提供一种方式标准化生产环境的部署. \n1. 不同“集装箱”间的，隔离性\n2. 标准化部署体验。 之前的云平台，不同的应用会有各自的部署流程，不同的平台部署流程也不一致。 现在只要统一支持docker那部署体验就是比较一致的。\n--\x3e\n<p><img src="https://deploybot.com/assets/guides/_740x345_crop_center-center/docker-head-big@2x.png" alt="docker"></p>\n<hr>\n\x3c!-- note\n1. 不同的应用程序的运行环境是不同的\n  1. 操作系统，库，组件..旧模块还可能于当前环境不兼容\n  2. 不同硬件/软件组合多种多样\n2. 随着硬件性能提升\n  1. 硬件性能过剩\n  2. 软件冲突\n--\x3e\n<h1 id="解决的问题">解决的问题 </h1>\n<ul>\n<li>软件冲突</li>\n<li>硬件性能过剩</li>\n<li>部署环境配置繁琐</li>\n</ul>\n<hr>\n<h1 id="container-vs-vm">Container vs VM</h1>\n<ul>\n<li>VMs</li>\n<li>Linux容器</li>\n</ul>\n<p><img src="http://p0.meituan.net/scarlett/711e764105828f0011ef33d00dad4c5046428.png" alt="VM vs Container"></p>\n<hr>\n<h1 id="pros--cons">PROS &amp; CONS</h1>\n<div class="grid">\n  <div class="column">\n    <h3>优点</h3>\n    <ol>\n      <li>资源利用率更高</li>\n      <li>轻量级启动速度快</li>\n      <li>方便简化部署</li>\n      <li>优化运维管理方案</li>\n    </ol>\n  </div>\n  <div class="column">\n    <h3>缺点</h3>\n    <ol>\n      <li>docker可以看作是进程隔离，隔离性不如VMs严格</li>\n    </ol>\n  </div>\n</div>\n\n<hr>\n\x3c!-- note \nDocker版本\n  1. 社区版(Community Edition, 简称CE)\n  2. 企业版(Enterprise Edition, 简称EE)\n\n    ps: 具体区别可见这里[docker-CE VS docker-EE](https://boxboat.com/2018/12/07/docker-ce-vs-docker-ee/)\n\n  版本号：\n  1. 2017以前最新的docker版本为v1.13, 发布CE和EE后版本格式变为v18.09.02\n\n    ps: 最新的版本号格式为YY.MM.<patch>\n\n  ps: \n  CE分为\'stable\',\'test\'和\'nightly\'，\'stable\'的发版周期为半年.\n\n--\x3e\n<h1 id="docker发展过程">docker发展过程</h1>\n<ul>\n<li>2013.3 docker发布, github pr贡献增长迅猛,下载量超10万次</li>\n<li>2013.10 dotcloud(已更名为Docker Inc. )</li>\n<li>2017 发布docker ce / ee (<a href="https://boxboat.com/2018/12/07/docker-ce-vs-docker-ee/">ce vs ee</a>)</li>\n</ul>\n<hr>\n<h1 id="安装">安装</h1>\n<ul>\n<li><a href="https://docs.docker.com/docker-for-mac/install/">Mac</a></li>\n<li><a href="https://docs.docker.com/docker-for-mac/docker-toolbox/">Docker Desktop for Mac vs. Docker Toolbox</a></li>\n</ul>\n'},337:function(n,e){n.exports='<h1 id="docker核心概念">docker核心概念</h1>\n<ul>\n<li>构成组件</li>\n<li>镜像 &amp; 容器</li>\n<li>registry服务与仓库</li>\n<li>network &amp; volumn</li>\n<li>docker-compose</li>\n</ul>\n<hr>\n<h1 id="docker架构">docker架构</h1>\n<p><img src="https://docs.docker.com/engine/images/architecture.svg" alt="docker c/s架构"></p>\n<hr>\n\x3c!-- note \n(代码，运行时，库文件，环境变量，配置文件, etc.)\n最下层是bootfs, 它主负责image的装载，做为用户我们几乎是不用和它打交道的，当image装载到内存以后，bootfs这层会被卸载掉\n接着是base image, 一般会是一个操作系统。但任何一个image都可以拿来当base image的，比方说我们可以把一个安装好了node环境的image当成base\n上面的话就是我们对base image的一些更改，装我们应用的运行环境, 每一条操作指令都会行成一个新的层，而且这些层都是只读层\n\n介绍下写时复制, device driver\n这个是docker image的一个大概工作流程\n--\x3e\n<h1 id="镜像">镜像</h1>\n<p>image是一个可执行包，包含程序运行所需要的一切</p>\n<div class="grid">\n  <div class="column">\n    <ol>\n      <li>写时复制</li>\n      <li>构建image(Dockerfile)</li>\n    </ol>\n    <pre style="margin-top: 30px;">\n      docker pull [imagename]\n      docker image ls\n      docker build -t [imagename] [directory contains Dockerfile]\n    </pre>\n  </div>\n  <div class="column">\n    <img src="https://www.ontrack.com/blog/wp-content/uploads/sites/7/docker.png" alt="docker image">\n  </div>\n</div>\n\n<hr>\n<h1 id="dockerfile">Dockerfile</h1>\n<pre><code>FROM node:8\n\nWORKDIR /app\n\n# 首先只copy package.json和package-lock.json, 这样可以更好的复用docker的层, @see http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/\nCOPY package*.json ./\n\n# RUN指令会在shell里使用命令包装器/bin/sh -c来执行\n# RUN指令会新建一个新的层，经常被用于安装软件包\nRUN npm install\n\nCOPY . .\n\nEXPOSE 80\n\n# 设置默认的启动参数，可以在容器启动时通过命令行修改\nCMD [ &quot;npm&quot;, &quot;start&quot; ]\n\n</code></pre><hr>\n\x3c!-- classes: page pre-max-w-50 --\x3e\n\n\x3c!-- note \ndocker run --name test-alpine -it alpine /bin/sh\n--\x3e\n\n<h1 id="容器">容器</h1>\n<p>容器是image的运行实例。</p>\n<pre><code>docker container ls\ndocker run --name [container name] -d -p 4000:80 [imagename]\ndocker container stop [imagename]\ndocker container rm [imagename]\ndocker container logs -f [container id/name]</code></pre><hr>\n\x3c!-- classes: page pre-max-w-50 --\x3e\n\n\x3c!-- note \n演示下docker hub的页面\n--\x3e\n<h1 id="registry--仓库repository">registry &amp; 仓库(Repository)</h1>\n<pre><code>docker login [registry]\ndocker tag [imagename] username/repo:tag\ndocker push username/repo:tag</code></pre><hr>\n\x3c!-- note \ndocker是推荐一个容器里只运行一个进程\n我们一个应用一般都会由一组服务组成，那就需要每个服务运行在一个container里. \ncontainer之间通信，一般是通过把它们放到一个network里来进行的\n\nvolumn的作用是持久化数据么，我们在container可写层做的更改都是临时性的，当container重启时会消失的。要想持久会数据一般方法是通过volumn\n--\x3e\n<h1 id="network--volumn">network &amp; volumn</h1>\n<ul>\n<li>network: 容器间通信</li>\n<li>volumn: 数据持久化/共享</li>\n</ul>\n<hr>\n\x3c!-- classes: page pre-max-w-50 --\x3e\n\n\x3c!-- note \n我们一个应用一般由多个服务构成的么，那起每个服务都去跑docker run也比较麻烦\n所以这个工具可以让我们以声明性的方式，指明我们要启动的那些container\n--\x3e\n<h1 id="docker-compose">docker-compose</h1>\n<p>只要用于多容器环境的启动/管理</p>\n<pre><code>docker-compose up\ndocker-compose down\n</code></pre><hr>\n<h1 id="docker-composeyml">docker-compose.yml</h1>\n<pre><code>version: &quot;3&quot;\nservices:\n  web:\n    container_name: node_web\n    build: .\n    command: [&quot;npm&quot;, &quot;run&quot;, &quot;dev:debug&quot;]\n    ports:\n      - &quot;8088:80&quot;\n      - &quot;9229:9229&quot;\n    networks:\n      - webnet\n    volumes:\n      - .:/app\n  redis:\n    container_name: redis_primary\n    image: &quot;redis:alpine&quot;\n    networks:\n      - webnet\n    volumes:\n      - ./data:/data\nnetworks:\n  webnet:</code></pre><hr>\n<h1 id="demo">Demo</h1>\n'},338:function(n,e){n.exports='\x3c!-- note\n1. 生产环境部署之前，需要先把image推到公共仓库\n  当然你打个tar包然后，上传到服务器上去也行\n--\x3e\n<h1 id="生产环境部署">生产环境部署</h1>\n<ul>\n<li>swarm</li>\n<li>service</li>\n<li>stack</li>\n</ul>\n<hr>\n<h1 id="swarm">swarm</h1>\n<div class="grid">\n  <div class="column">\n    <pre style="margin-top: 30px;">\n      docker swarm init\n      docker swarm leave --force\n      docker node ls\n      // 显示join-token\n      docker swarm join-token worker\n    </pre>\n  </div>\n  <div class="column">\n    <img src="https://docs.docker.com/engine/swarm/images/ingress-routing-mesh.png" alt="docker swarm">\n  </div>\n</div>\n\n<hr>\n\x3c!-- note\ndocker stack deploy -c docker-compose.yml node-docker-demo\ndocker stack ps node-docker-demo\ndocker stack rm node-docker-demo\n--\x3e\n\n<h1 id="service--stack">service &amp; stack</h1>\n<hr>\n<h1 id="q--a">Q &amp; A</h1>\n<hr>\n<h1 id="thanks">THANKS</h1>\n'},340:function(n,e,o){var r=o(341);"string"==typeof r&&(r=[[n.i,r,""]]);var i={hmr:!0,transform:void 0,insertInto:void 0};o(50)(r,i);r.locals&&(n.exports=r.locals)},341:function(n,e,o){}},[[134,3,5]],[0]]);